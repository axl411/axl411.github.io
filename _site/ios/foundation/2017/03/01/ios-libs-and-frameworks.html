<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>iOS Libs 与 Frameworks 的理解和使用 | axl411</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="iOS Libs 与 Frameworks 的理解和使用" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="(also posted on 饿了么移动组 Blog)" />
<meta property="og:description" content="(also posted on 饿了么移动组 Blog)" />
<link rel="canonical" href="/ios/foundation/2017/03/01/ios-libs-and-frameworks.html" />
<meta property="og:url" content="/ios/foundation/2017/03/01/ios-libs-and-frameworks.html" />
<meta property="og:site_name" content="axl411" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-03-01T00:25:05+09:00" />
<script type="application/ld+json">
{"url":"/ios/foundation/2017/03/01/ios-libs-and-frameworks.html","headline":"iOS Libs 与 Frameworks 的理解和使用","dateModified":"2017-03-01T00:25:05+09:00","description":"(also posted on 饿了么移动组 Blog)","datePublished":"2017-03-01T00:25:05+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/ios/foundation/2017/03/01/ios-libs-and-frameworks.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="axl411" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">axl411</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">iOS Libs 与 Frameworks 的理解和使用</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-03-01T00:25:05+09:00" itemprop="datePublished">Mar 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>(also posted on <a href="http://mobilists.eleme.io/2017/02/28/iOS-Libs-与-Frameworks-的理解和使用/">饿了么移动组 Blog</a>)</p>

<p>本文将从两个角度——理论与实践，来介绍 iOS 开发中接触到的动态库、静态库、framework。理论部分会以简单的例子来建立对概念的理解；实践部分则是使用 cocoapods 的一些技巧。</p>

<h1 id="名词">名词</h1>

<p>首先我们熟悉一下以下名词概念：</p>

<ul>
  <li>
    <p>代码（code）：不止是指源代码（source code）形式的代码，也指代编译后产生的二进制代码。</p>
  </li>
  <li>
    <p>Mach-O：操作系统能够使用的二进制文件格式，很多种类的文件都是 Mach-O 文件，包括动态库、静态库、可执行文件，都是 Mach-O 文件。本文将替换使用多种代称，比如 <code class="highlighter-rouge">object file</code>、<code class="highlighter-rouge">对象文件</code>，都是指同一个概念。</p>
  </li>
  <li>
    <p>动态库、 dynamic linked library、dynamic library、shared library、embedded shared library 这些名词都是指动态库。</p>
  </li>
</ul>

<h1 id="理解-libs-与-frameworks">理解 Libs 与 Frameworks</h1>

<p>Libs（库），或是 Frameworks，无论静态还是动态，都是一种依赖管理的形式，其最终目的都是将程序依赖的<code class="highlighter-rouge">代码</code>载入到程序所在进程的地址空间中，从而让我们的程序能够使用它们。静态库、动态库只是用了不同的机制来实现这个目的。</p>

<h2 id="静态库">静态库</h2>

<p>我们直接以一个简单的例子讲述如何创建静态库并使用它，从而对静态库建立一个简单的概念。</p>

<h3 id="制作静态库">制作静态库</h3>

<p>有如下两个简单的源代码 <code class="highlighter-rouge">bar.h</code> 和 <code class="highlighter-rouge">bar.c</code>。<code class="highlighter-rouge">bar.c</code> 中声明了 <code class="highlighter-rouge">fizz</code> 函数，使用 <code class="highlighter-rouge">CoreFoundation</code> 的方法打印一个字符串 <code class="highlighter-rouge">buzz</code>，<code class="highlighter-rouge">bar.h</code> 将 <code class="highlighter-rouge">fizz</code> 函数暴露了出来：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bar.h</span>
<span class="cp">#ifndef __foo__bar__
#define __foo__bar__
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">fizz</span><span class="p">();</span>

<span class="cp">#endif </span><span class="cm">/* defined(__foo__bar__) */</span><span class="cp">
</span>
<span class="c1">// bar.c</span>
<span class="cp">#include "bar.h"
#include &lt;CoreFoundation/CoreFoundation.h&gt;
</span>
<span class="kt">int</span> <span class="nf">fizz</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">CFShow</span><span class="p">(</span><span class="n">CFSTR</span><span class="p">(</span><span class="s">"buzz"</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">clang</code> 将 <code class="highlighter-rouge">bar.c</code> 编译为  <code class="highlighter-rouge">bar.o</code>。为了简化问题，我们只输出为 <code class="highlighter-rouge">x86_64</code> 处理器架构编译的结果。从 <code class="highlighter-rouge">file</code> 命令的输出可以看到，输出的 <code class="highlighter-rouge">bar.o</code> 是 <code class="highlighter-rouge">Mach-O</code> object file：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-c</span> bar.c <span class="nt">-o</span> bar.o <span class="nt">-arch</span> x86_64
<span class="nv">$ </span>file bar.o
bar.o: Mach-O 64-bit object x86_64
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">libtool</code>，以 <code class="highlighter-rouge">bar.o</code> 为输入，输出一个名称为 <code class="highlighter-rouge">libfoo_static.a</code> 的静态库。从 <code class="highlighter-rouge">file</code> 的输出可以看到，静态库的文件类型是 <code class="highlighter-rouge">current ar archive random library</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>libtool <span class="nt">-static</span> bar.o <span class="nt">-o</span> libfoo_static.a
<span class="nv">$ </span>file libfoo_static.a
libfoo_static.a: current ar archive random library
</code></pre></div></div>

<h3 id="使用静态库">使用静态库</h3>

<p>有如下简单的 <code class="highlighter-rouge">main.c</code> 源代码，通过 <code class="highlighter-rouge">bar.h</code> 调用了 <code class="highlighter-rouge">fizz</code> 函数：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.c</span>
<span class="cp">#include "bar.h"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fizz</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>和制作静态库一样，用 <code class="highlighter-rouge">clang</code> 将 <code class="highlighter-rouge">main.c</code> 编译为 <code class="highlighter-rouge">main.o</code>。<code class="highlighter-rouge">main.o</code> 和 <code class="highlighter-rouge">bar.o</code> 的类型一样，都是 object file：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-c</span> main.c <span class="nt">-o</span> main.o <span class="nt">-arch</span> x86_64
<span class="nv">$ </span>file main.o
main.o: Mach-O 64-bit object x86_64
</code></pre></div></div>

<p>用 <code class="highlighter-rouge">ld</code>（linker／链接器）来输出一个名为 <code class="highlighter-rouge">test_static</code> 的可执行文件。<code class="highlighter-rouge">ld</code> 接收的输入有：<code class="highlighter-rouge">main.o</code>、<code class="highlighter-rouge">CoreFoundation</code> framework、额外指定了当前文件夹为 library search path（<code class="highlighter-rouge">-L.</code>）、<code class="highlighter-rouge">libfoo_static</code>（<code class="highlighter-rouge">-lfoo_static</code>，正是因为额外指定了当前文件夹为 library search path 才能够找到它）、为简化问题只对 <code class="highlighter-rouge">x86_64</code> 架构编译（-lSystem 表示 libsystem，可以忽略，不影响对概念的理解）。通过 <code class="highlighter-rouge">file</code> 的输出可以看到 <code class="highlighter-rouge">test_static</code> 可执行文件也是一种 <code class="highlighter-rouge">Mach-O</code> 文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ld main.o <span class="nt">-framework</span> CoreFoundation <span class="nt">-lSystem</span> <span class="nt">-L</span><span class="nb">.</span> <span class="nt">-lfoo_static</span> <span class="nt">-o</span> test_static <span class="nt">-arch</span> x86_64
<span class="nv">$ </span>file test_static
test_static: Mach-O 64-bit executable x86_64
</code></pre></div></div>

<p>执行 <code class="highlighter-rouge">test_static</code>，功能正常，输出了 <code class="highlighter-rouge">buzz</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./test_static
buzz
</code></pre></div></div>

<h3 id="分析">分析</h3>

<p>用 <code class="highlighter-rouge">nm</code> 查看 <code class="highlighter-rouge">test_static</code> 可执行文件的符号表（symbol table），留意如下信息：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">_CFShow</code>、<code class="highlighter-rouge">___CFConstantStringClassReference</code> 是来自 <code class="highlighter-rouge">CoreFoundation</code> framework 的 symbol，在这里还未被 resolve（即还没有指令所在的地址），这是因为 <code class="highlighter-rouge">CoreFoundation</code> framework 是动态链接的，两个 symbol 代表的指令的地址并不会在编译时被 resolve。（后面讲动态链接会介绍动态链接的 symbol 是如何 resolve 的）</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">_fizz</code> symbol 是来自静态库 <code class="highlighter-rouge">libfoo_static</code> 的，在这里已经被 resolve 了，即具体的指令已经存在于 <code class="highlighter-rouge">test_static</code> 的二进制中了。</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nm test_static
                 U _CFShow
                 U ___CFConstantStringClassReference
0000000100000000 T __mh_execute_header
0000000100000f70 T _fizz
0000000100000f50 T _main
                 U dyld_stub_binder
</code></pre></div></div>

<p>查看 <code class="highlighter-rouge">libfoo_static</code> 以及 <code class="highlighter-rouge">bar.o</code> 的符号表，我们发现：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">libfoo_static</code> 和 <code class="highlighter-rouge">bar.o</code> 的符号表内容是完全一样的。</p>
  </li>
  <li>
    <p>从 <code class="highlighter-rouge">libfoo_static.a(bar.o):</code> 看出，静态库会把它包含的所有 object file 的符号表分别输出，静态库只是简单的 object file 的集合，这里 <code class="highlighter-rouge">libfoo_static</code> 只包含了一个 <code class="highlighter-rouge">bar.o</code>。</p>
  </li>
  <li>
    <p>一样有 unresolved 的 <code class="highlighter-rouge">CoreFoundation</code> 的 symbol。</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nm libfoo_static.a
libfoo_static.a<span class="o">(</span>bar.o<span class="o">)</span>:
                 U _CFShow
                 U ___CFConstantStringClassReference
0000000000000000 T _fizz

<span class="nv">$ </span>nm bar.o
                 U _CFShow
                 U ___CFConstantStringClassReference
0000000000000000 T _fizz
</code></pre></div></div>

<p>用 <code class="highlighter-rouge">otool</code> 查看 <code class="highlighter-rouge">libfoo_static</code> 对 shared library 的依赖，没有看到任何依赖信息，因此指定依赖的责任自然就到了静态库的使用方。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>otool <span class="nt">-L</span> libfoo_static.a
Archive : libfoo_static.a
libfoo_static.a<span class="o">(</span>bar.o<span class="o">)</span>:
</code></pre></div></div>

<p>一个典型的静态库的例子是微信 SDK。它的接入文档会提到：</p>
<blockquote>
  <p>SDK文件包括 libWeChatSDK.a，WXApi.h，WXApiObject.h 三个</p>
</blockquote>

<p>并且：</p>
<blockquote>
  <p>开发者需要在工程中链接上:SystemConfiguration.framework, libz.dylib, libsqlite3.0.dylib, libc++.dylib, Security.framework, CoreTelephony.framework, CFNetwork.framework</p>
</blockquote>

<p>这和我们看到的例子中自己制作的静态库概念是一样的。</p>

<h3 id="小结">小结</h3>

<p>经过具体的例子，我们可以理解关于静态库的如下概念：</p>

<ul>
  <li>
    <p>静态库就是 object file 的集合。</p>
  </li>
  <li>
    <p>因此，在使用静态库的时候需要自行指定静态库的任何依赖。</p>
  </li>
  <li>
    <p>静态链接会直接将静态库中的 object file 加到 target（比如 <code class="highlighter-rouge">test_static</code> 可执行文件） 中去。</p>
  </li>
</ul>

<h2 id="动态库">动态库</h2>

<p>动态库和静态库的最大区别是，动态库的代码不会直接加入到目标程序中，而是在启动时由 dynamic link editor <code class="highlighter-rouge">dyld</code> 加载到 app 的内存地址空间；另外，动态库包含自己的依赖信息。下面我们依然通过实例来理解这个概念。</p>

<h3 id="制作动态库">制作动态库</h3>

<p>复用前面制作静态库时编译出的 <code class="highlighter-rouge">bar.o</code>，依然使用 <code class="highlighter-rouge">libtool</code>，生成名为 <code class="highlighter-rouge">libfoo_dynamic.dylib</code> 的动态库。注意这里需要指定 <code class="highlighter-rouge">CoreFoundation</code> framework（可以忽略 -lSystem，不影响对概念的理解）。生成的 <code class="highlighter-rouge">libfoo_dynamic</code> 的文件类型是动态库：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>libtool <span class="nt">-dynamic</span> bar.o <span class="nt">-o</span> libfoo_dynamic.dylib <span class="nt">-framework</span> CoreFoundation <span class="nt">-lSystem</span>
<span class="nv">$ </span>file libfoo_dynamic.dylib
libfoo_dynamic.dylib: Mach-O 64-bit dynamically linked shared library x86_64
</code></pre></div></div>

<p>使用 linker <code class="highlighter-rouge">ld</code> 来输出一个可执行文件 <code class="highlighter-rouge">test_dynamic</code>。这次的输入是同样复用前面编译出的 <code class="highlighter-rouge">main.o</code>、<code class="highlighter-rouge">foo_dynamic</code> 动态库（忽略 <code class="highlighter-rouge">-lSystem</code>），并指定当前文件夹 <code class="highlighter-rouge">.</code>（也就是 <code class="highlighter-rouge">foo_dynamic</code> 动态库所在的文件夹） 为 library search path。<code class="highlighter-rouge">test_dynamic</code> 同样是 <code class="highlighter-rouge">Mach-O</code> 可执行文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ld main.o <span class="nt">-lSystem</span> <span class="nt">-L</span><span class="nb">.</span> <span class="nt">-lfoo_dynamic</span> <span class="nt">-o</span> test_dynamic <span class="nt">-arch</span> x86_64
<span class="nv">$ </span>file test_dynamic
test_dynamic: Mach-O 64-bit executable x86_64
</code></pre></div></div>

<p>执行 <code class="highlighter-rouge">test_dynamic</code>，同样能够输出正确的结果：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./test_dynamic
buzz
</code></pre></div></div>

<h3 id="分析-1">分析</h3>

<p>用 <code class="highlighter-rouge">nm</code> 查看 <code class="highlighter-rouge">test_dynamic</code> 可执行文件的 symbol table，留意如下信息：</p>

<ul>
  <li>
    <p>来自 <code class="highlighter-rouge">CoreFoundation</code> framework 的 <code class="highlighter-rouge">_CFShow</code>、<code class="highlighter-rouge">___CFConstantStringClassReference</code> symbol 并没有存在于 <code class="highlighter-rouge">test_dynamic</code> 的符号表中。<code class="highlighter-rouge">_fizz</code> 符号只是个 reference，并没有被 resolve。</p>
  </li>
  <li>
    <p>来自动态库 <code class="highlighter-rouge">libfoo_dynamic</code> 的 <code class="highlighter-rouge">_fizz</code> symbol 在这里并没有被 resolve。</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nm test_dynamic
0000000100000000 T __mh_execute_header
                 U _fizz
0000000100000f70 T _main
                 U dyld_stub_binder
</code></pre></div></div>

<p>查看 <code class="highlighter-rouge">libfoo_dynamic</code> 以及 <code class="highlighter-rouge">bar.o</code> 的符号表，我们发现：</p>

<ul>
  <li><code class="highlighter-rouge">libfoo_dynamic</code> 和 <code class="highlighter-rouge">bar.o</code> 的 symbol table 内容并不是完全一样的，<code class="highlighter-rouge">_fizz</code> symbol 的地址在两者的 symbol table 中是不同的。</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nm libfoo_dynamic.dylib
                 U _CFShow
                 U ___CFConstantStringClassReference
0000000000000f70 T _fizz
                 U dyld_stub_binder

<span class="nv">$ </span>nm bar.o
                 U _CFShow
                 U ___CFConstantStringClassReference
0000000000000000 T _fizz
</code></pre></div></div>

<p>用 <code class="highlighter-rouge">otool</code> 查看 <code class="highlighter-rouge">libfoo_dynamic</code> 的依赖信息，可以看到 <code class="highlighter-rouge">CoreFoundation</code> 是在里面的（同样，忽略 <code class="highlighter-rouge">libSystem</code>），因此使用方就不需要指定这个依赖了：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>otool <span class="nt">-L</span> libfoo_dynamic.dylib
libfoo_dynamic.dylib:
	libfoo_dynamic.dylib <span class="o">(</span>compatibility version 0.0.0, current version 0.0.0<span class="o">)</span>
	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation <span class="o">(</span>compatibility version 150.0.0, current version 1348.28.0<span class="o">)</span>
	/usr/lib/libSystem.B.dylib <span class="o">(</span>compatibility version 1.0.0, current version 1238.0.0<span class="o">)</span>
</code></pre></div></div>

<p>经过具体的例子，我们可以理解关于动态库的如下概念：</p>

<ul>
  <li>
    <p>动态库包含了自己的依赖信息，因此，在使用动态库的时候直接使用动态库就可以。</p>
  </li>
  <li>
    <p>动态链接并不会直接将动态库中的 object file 加到 target（比如 <code class="highlighter-rouge">test_dynamic</code> 可执行文件） 中去。</p>
  </li>
</ul>

<h3 id="程序是如何使用动态库的">程序是如何使用动态库的</h3>

<p>当执行程序时，例如执行 <code class="highlighter-rouge">./test_dynamic</code> 时，在其 <code class="highlighter-rouge">main</code> 函数被调用前，Kernel 除了会把 <code class="highlighter-rouge">test_dynamic</code> 载入到为其分配的内存空间外，还会载入 <code class="highlighter-rouge">dyld</code> linker，然后 <code class="highlighter-rouge">dyld</code> 会根据 <code class="highlighter-rouge">test_dynamic</code> 的依赖信息，将它依赖的 shared library（也就是 <code class="highlighter-rouge">libfoo_dynamic</code>）以及这些 shared library 的依赖（也就是 <code class="highlighter-rouge">CoreFoundation</code>）同样载入到内存地址空间。<code class="highlighter-rouge">test_dynamic</code> 中未 resolve 的 <code class="highlighter-rouge">_fizz</code> symbol 会在这时被 resolve。</p>

<p>这些 shared library 实际上在设备的物理内存中只存在一份，通过一个 mapping 的机制让它们能同时存在于多个应用的内存地址空间中。</p>

<p>另外，既然在物理内存中只存在一份，那多个应用使用的同一个 shared library 中的同一个变量是如何有对于该应用而言独有的 value 的呢？知道 Copy on Write 机制，字面意思就是在写操作时就 copy 一份这个概念就行了。</p>

<p>具体的细节可以参考<a href="https://developer.apple.com/videos/play/wwdc2016/406/">这集WWDC</a>。</p>

<h2 id="framework">Framework</h2>

<p>在理解了动态库、静态库的基础上，framework 只是一个后缀为 <code class="highlighter-rouge">.framework</code> 的文件夹，包含了额外的资源，例如头文件、图片、文档、多语言支持资源、nib 等等。虽然 Framework  还有版本的概念，可以同时包含多个版本的 framework 在同一个 <code class="highlighter-rouge">.framework</code> 内，但对于 iOS 来说这不重要，因为我们的 Framework 是随 app 的 bundle 一起发布的，不存在被多方使用的问题。动态库在 app bundle 内的位置如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MyApp.app
├── Frameworks
│   └── MyDylib.dylib
│   └── MyFramework.framework
</code></pre></div></div>

<h1 id="用-cocoapods使用-libs-与-frameworks">（用 cocoapods）使用 Libs 与 Frameworks</h1>

<blockquote>
  <p>将 libWeChatSDK.a，WXApi.h，WXApiObject.h 这三个拖到主工程</p>
</blockquote>

<blockquote>
  <p>开发者需要在工程中链接上:a.framework, b.dylib, c.dylib, d.dylib, e.framework, f.framework, g.framework</p>
</blockquote>

<blockquote>
  <p>将 a.png，b.png，c.js 拖到主工程</p>
</blockquote>

<p>手动接入某个库或 Framework 往往需要做上面这些手动的事情，时间一长、接入的多了，非常不利于项目的维护。</p>

<p><a href="https://cocoapods.org/"><code class="highlighter-rouge">cocoapods</code></a> 提供了非常好的依赖管理机制，并且可以用来对我们要使用的库、framework 进行封装，方便管理维护，不管是静态库、动态库还是 framework，只要填写一份统一的 <code class="highlighter-rouge">podspec</code>，就能完成对依赖的封装。如下所示，封装一个依赖的 <code class="highlighter-rouge">podspec</code> 通常涉及到填写这些属性：</p>

<ul>
  <li><code class="highlighter-rouge">vendored_frameworks</code>：要封装的 framework 的路径</li>
  <li><code class="highlighter-rouge">vendored_libraries</code>：要封装的 lib 的路径</li>
  <li><code class="highlighter-rouge">source_files</code>：这里只需要填写想要暴露的头文件的路径</li>
  <li><code class="highlighter-rouge">libraries</code>：要封装的库所需要的依赖库</li>
  <li><code class="highlighter-rouge">frameworks</code>：要封装的库所依赖的 framework</li>
  <li><code class="highlighter-rouge">weak_framework</code>：要封装的库所依赖的 weak link 的 framework，例如 <code class="highlighter-rouge">UserNotifications</code> framework 是一个 iOS 10 才有的 framework，通过 weak linking + runtime availability check，可以在低于 iOS 10 的平台上安全地跑起来</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spec</span><span class="p">.</span><span class="nf">vendored_frameworks</span> <span class="o">=</span> <span class="s1">'a.framework'</span><span class="p">,</span> <span class="s1">'b.framework'</span>
<span class="n">spec</span><span class="p">.</span><span class="nf">vendored_libraries</span> <span class="o">=</span> <span class="s1">'liba.a'</span><span class="p">,</span> <span class="s1">'libb.a'</span>
<span class="n">spec</span><span class="p">.</span><span class="nf">source_files</span> <span class="o">=</span> <span class="err">‘</span><span class="no">Headers</span><span class="o">/</span><span class="no">Public</span><span class="o">/*</span><span class="p">.</span><span class="nf">h</span><span class="s1">'
spec.libraries = '</span><span class="n">xml2</span><span class="s1">', '</span><span class="n">z</span><span class="s1">'
spec.frameworks = '</span><span class="no">QuartzCore</span><span class="s1">', ‘CoreData'</span>
<span class="n">spec</span><span class="p">.</span><span class="nf">weak_framework</span> <span class="o">=</span> <span class="err">‘</span><span class="no">UserNotifications</span><span class="err">’</span>
</code></pre></div></div>

<h2 id="静态库转动态库">静态库转动态库</h2>

<p>一般不推荐这么做，不过把静态库转动态库也是可行的。</p>

<p>操作的方法是：</p>

<ul>
  <li>确保该静态库包含全部需要的架构。</li>
  <li>用 Xcode 创建一个 Cocoa Touch Framework 的 project，用来封装静态库。</li>
  <li>把静态库、静态库的头文件正常手动加入到项目中。</li>
  <li>在 Build Settings 中的 Other Linker Flags 中加入 <code class="highlighter-rouge">-all_load</code> flag，从而在 link 时把所有静态库中的代码加载进来。</li>
  <li>在 Build Settings 中的 Framework Search Paths 以及 Library Search Paths 中添加静态库所在的路径，从而在 compile 时能找到该静态库。</li>
  <li>在 Build Phase 中的 Link Binary With Libraries 区域加入添加的静态库。</li>
  <li>在 Build Phase 中的 Headers 区域把要暴露的头文件移到 Public。</li>
  <li>根据静态库的接入文档，在工程中链接上需要的其他库、framework。</li>
  <li>到这一步应该编译通过了。</li>
  <li>目前的 Xcode 只会输出 only 模拟器 or only device 架构的动态库，因此为了生成一个可同时被模拟器以及真机使用的动态库，需要输出两次，并用 <code class="highlighter-rouge">lipo</code> 工具把架构合并。</li>
  <li>蛋疼的是，当使用这个动态库的工程打包时，又需要用 <code class="highlighter-rouge">lipo</code> 工具把不需要的架构去掉（也就是为真机打包时，要去掉模拟器的架构）。</li>
</ul>

<p>正是因为需要做这么多额外的工作，因此不推荐这么做。不过，把生成的动态库用 cocoapods 封装的话，cocoapods 在安装时会生成自动去除不需要架构的 build phase。</p>

<p>这么做有一个风险就是，由于改变了链接库的方式，最后库的资源在 iOS app 中的路径也会改变，如果库的开发者在编写库时取资源的姿势做了简单的假设的话（假设资源肯定在 app 的 main bundle 中），就会取不到资源了。下一章将详细介绍一下在库中取资源的姿势。</p>

<h2 id="资源的读取">资源的读取</h2>

<p>在 pod 中取资源不能简单假设资源所在的位置，否则会取不到资源。我们直接通过例子来看这个问题。假设有下面这样一个 pod：</p>

<ul>
  <li>名字叫 <code class="highlighter-rouge">MyPod</code></li>
  <li>通过 <code class="highlighter-rouge">resources</code> 来指定资源，这是不推荐的做法</li>
  <li>通过 <code class="highlighter-rouge">resource_bundles</code> 来指定资源，这是推荐的做法</li>
  <li>包含的资源是名叫 <code class="highlighter-rouge">img.png</code> 的图片</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="err">‘</span><span class="no">MyPod</span><span class="err">’</span>

<span class="c1"># 不推荐的做法</span>
<span class="n">s</span><span class="p">.</span><span class="nf">resources</span> <span class="o">=</span> <span class="err">“</span><span class="c1">#{PATH_TO_RESOURCE}”</span>

<span class="n">s</span><span class="p">.</span><span class="nf">resource_bundles</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">'MyPod'</span> <span class="o">=&gt;</span> <span class="s2">"</span><span class="si">#{</span><span class="no">PATH_TO_RESOURCE</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
</code></pre></div></div>

<p>然后，我们有一个 iOS app 叫做 <code class="highlighter-rouge">MyApp</code>，用 3 种姿势来使用这个 pod：</p>

<ul>
  <li>case 1：在 <code class="highlighter-rouge">Podfile</code> 里用 <code class="highlighter-rouge">use_frameworks!</code> 来安装 pod（pod 会被编译为动态库）</li>
  <li>case 2：在 <code class="highlighter-rouge">Podfile</code> 里不用 <code class="highlighter-rouge">use_frameworks!</code> 来安装 pod（pod 会被编译为静态库）</li>
  <li>case 3：在 <code class="highlighter-rouge">MyApp</code> 工程里手动建一个名叫 <code class="highlighter-rouge">MyHandMadeFramework</code> 的 Cocoa Touch Framework，并通过 pod 把 <code class="highlighter-rouge">MyPod</code> 安装在 <code class="highlighter-rouge">MyHandMadeFramework</code> 的 target 上，然后 <code class="highlighter-rouge">MyApp</code> 手动引入 <code class="highlighter-rouge">MyHandMadeFramework</code> 来使用。这种 case 虽然绕了点，但也是完全合理的一种使用姿势，并且资源在这种 case 下所在的位置是比较特别的。</li>
</ul>

<h3 id="用-resources-指定资源的情况">用 <code class="highlighter-rouge">resources</code> 指定资源的情况</h3>

<p>最终 <code class="highlighter-rouge">img.png</code> 在3种情况下编译出来的 app 中的路径如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// "case 1"
MyApp.app/Frameworks/MyPod.framework/img.png
// "case 2"
MyApp.app/img.png
// "case 3"
MyApp.app/Frameworks/MyHandMadeFramework.framework/img.png
</code></pre></div></div>

<p>因此，如果在取资源的时候简单地假设资源肯定在 main bundle，用如下姿势去取的话，肯定是不 work 的：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="n">NSBundle</span> <span class="nf">mainBundle</span><span class="p">]</span> <span class="nf">pathForResource</span><span class="p">:</span><span class="s">@"img"</span> <span class="nf">ofType</span><span class="p">:</span><span class="err">@“</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</code></pre></div></div>

<p>正确的做法是用 <code class="highlighter-rouge">bundleForClass</code> 取出 <code class="highlighter-rouge">MyPod</code> 的代码所在的 bundle:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSBundle</span> <span class="o">*</span><span class="n">bundleContainingPodsCode</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBundle</span> <span class="nf">bundleForClass</span><span class="p">:[</span><span class="n">self</span> <span class="nf">class</span><span class="p">]];</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">bundleContainingPodsCode</code> 的路径分别是：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// "case 1"
MyApp.app/Frameworks/MyPod.framework/
// "case 2"
MyApp.app/
// "case 3"
MyApp.app/Frameworks/MyHandMadeFramework.framework/
</code></pre></div></div>

<p>然后以这个 bundle 的相对路径去取资源就始终能取到正确的资源了：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSString</span> <span class="o">*</span><span class="n">imgPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">bundleContainingPodsCode</span> <span class="nf">pathForResource</span><span class="p">:</span><span class="s">@"img"</span> <span class="nf">ofType</span><span class="p">:</span><span class="err">@“</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="用-resource_bundles-指定资源的情况">用 <code class="highlighter-rouge">resource_bundles</code> 指定资源的情况</h3>

<p>最终 <code class="highlighter-rouge">img.png</code> 在3种情况下编译出来的 app 中的路径如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// "case 1"
MyApp.app/Frameworks/MyPod.framework/MyPod.bundle/img.png
// "case 2"
MyApp.app/MyPod.bundle/img.png
// "case 3"
MyApp.app/Frameworks/MyHandMadeFramework.framework/MyPod.bundle/img.png
</code></pre></div></div>

<p>可以看到这种情况和 <code class="highlighter-rouge">resources</code> 的情况区别在于：<code class="highlighter-rouge">img.png</code> 被额外放在了名叫 <code class="highlighter-rouge">MyPod.bundle</code> 的 bundle 内。因此，取资源的姿势上要额外把这个 bundle 取出来，再用相对路径去取资源：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSBundle</span> <span class="o">*</span><span class="n">libBundle</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBundle</span> <span class="nf">bundleForClass</span><span class="p">:[</span><span class="n">self</span> <span class="nf">class</span><span class="p">]];</span>
<span class="n">NSString</span> <span class="o">*</span><span class="n">resourceBundlePath</span> <span class="o">=</span> <span class="p">[[</span><span class="n">libBundle</span> <span class="nf">bundlePath</span><span class="p">]</span> <span class="nf">stringByAppendingPathComponent</span><span class="p">:</span><span class="s">@"MyPod.bundle"</span><span class="p">];</span>
<span class="n">NSBundle</span> <span class="o">*</span><span class="n">resourceBundle</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBundle</span> <span class="nf">bundleWithPath</span><span class="p">:</span><span class="n">resourceBundlePath</span><span class="p">];</span> <span class="c1">// 这里应该把 resourceBundle 缓存下来</span>

<span class="n">NSString</span> <span class="o">*</span><span class="n">imgPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">resourceBundle</span> <span class="nf">pathForResource</span><span class="p">:</span><span class="s">@"img"</span> <span class="nf">ofType</span><span class="p">:</span><span class="err">@“</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</code></pre></div></div>

<p>当然，如果你的 app 的 deployment target 为 iOS 8，那么可以直接用如下这个新的 api 来从 resource bundle 里取图片：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UIImage</span> <span class="o">*</span><span class="n">img</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageNamed</span><span class="p">:</span><span class="s">@"img"</span> <span class="nf">inBundle</span><span class="p">:</span><span class="n">resourceBundle</span> <span class="n">compatibleWithTraitCollection</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</code></pre></div></div>

  </div><a class="u-url" href="/ios/foundation/2017/03/01/ios-libs-and-frameworks.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">axl411</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">axl411</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/axl411"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">axl411</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
